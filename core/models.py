import uuid

from ambient_toolbox.mixins.bleacher import BleacherMixin
from ambient_toolbox.models import CommonInfo
from django.conf import settings
from django.contrib import admin
from django.db import models
from django.utils.functional import cached_property
from django.utils.translation import gettext_lazy as _


def generate_unique_value(model, field, value):
    """
    Creates a numeric or a random string suffix for the given value
    """
    SEP = "-"
    MAX_ITERATIONS = 10000

    numeric_suffix = 0

    _clean_value = (value or "").strip()
    new_value = _clean_value
    _value = f"{_clean_value}{SEP}"

    while model.objects.filter(**{field: new_value}).exists():
        if numeric_suffix > MAX_ITERATIONS:  # pragma: no cover
            # we already tried hard to find out a valueâ€¦
            # append a random string to the original value
            return f"{_value}{uuid.uuid4()}"

        numeric_suffix += 1
        new_value = f"{_value}{numeric_suffix}"

    return new_value


class CloneableMixin:
    """
    **CloneableMixin** add methods to clone the model instances.
    """

    AUTOGENERATED_FIELDS = []
    CACHED_FIELDS = []

    def clone(self):
        """
        Clones instance taking care of unique constraints (single)
        """
        if not self.is_cloneable():
            return None

        cls = self._meta.model
        new_entry = cls()
        for field in cls._meta.fields:
            if field.primary_key:
                continue

            attr_name = field.name
            if attr_name in self.AUTOGENERATED_FIELDS:
                continue

            value = getattr(self, attr_name)
            if value is None:
                continue

            if field.unique:
                # (avoid unique constraints)
                new_value = generate_unique_value(cls, attr_name, value)
                setattr(new_entry, attr_name, new_value)
            else:
                setattr(new_entry, attr_name, value)
        return new_entry

    @classmethod
    def cloneable(cls):
        """
        Indicates if these model instances are cloneable.

        If the model is not managed by the app then is not cloneable.
        If the model has any UniqueConstraint with more than one field
        then it is not possible to clone it without assistance.
        """
        if not cls._meta.managed:
            return False

        for constraint in cls._meta.constraints:
            if isinstance(constraint, models.UniqueConstraint) and len(constraint.fields) > 1:
                return False
        return True

    def is_cloneable(self):
        """
        Indicates if current instance is cloneable.
        """
        return self.cloneable()

    def save(self, *args, **kwargs):
        """
        Validate instance before saving it and refresh cached properties after saving.
        """

        self.full_clean()
        super().save(*args, **kwargs)

        # invalidates cached properties
        for key in self.CACHED_FIELDS:
            if key in self.__dict__:
                del self.__dict__[key]


class AuditAbstractModel(CloneableMixin, CommonInfo):
    """
    **AuditAbstractModel** introduce audit fields.

    .. note:: Extends from :class:`biskit.core.models.CloneableMixin`
    .. note:: Extends from :class:`ai_django_core.models.CommonInfo`
    """

    created_by = models.ForeignKey(
        blank=True,
        null=True,
        on_delete=models.PROTECT,  # override
        related_name="%(app_label)s_%(class)s_created",
        to=settings.AUTH_USER_MODEL,
        verbose_name=_("Created by"),
    )
    lastmodified_by = models.ForeignKey(
        blank=True,
        null=True,
        on_delete=models.PROTECT,  # override
        related_name="%(app_label)s_%(class)s_lastmodified",
        to=settings.AUTH_USER_MODEL,
        verbose_name=_("Last modified by"),
    )

    SEARCH_FIELDS = []
    FILTER_FIELDS = {
        "created_at": ["exact", "in", "range", "lt", "gt"],
        "created_by": ["exact", "in", "isnull"],
        "created_by__username": ["exact", "in"],
        "lastmodified_at": ["exact", "in", "range", "lt", "gt"],
        "lastmodified_by": ["exact", "in", "isnull"],
        "lastmodified_by__username": ["exact", "in"],
    }

    AUTOGENERATED_FIELDS = [
        *CloneableMixin.AUTOGENERATED_FIELDS,
        "created_at",
        "created_by",
        "lastmodified_at",
        "lastmodified_by",
    ]

    def set_user_fields(self, user):
        """
        Set user-related fields before saving the instance.
        If no user with primary key is given the fields are not set.

        :param user: user instance of current user
        """
        if user and user.pk:
            if not self.created_by:  # override
                self.created_by = user
            self.lastmodified_by = user

    class Meta:
        abstract = True


class BaseAbstractModel(AuditAbstractModel):
    """
    **BaseAbstractModel** is parent of other models in this app.

    :ivar UUID     id:         Primary key. *required*. Set automatically.
    :ivar boolean  is_active:  Is active? Default: *true*.
        -- An inactive instance will not appear in any the queries/searches.
        Neither their children.

    .. note:: Listed values are default ordered by `id` ascending.
    .. note:: Extends from :class:`biskit.core.models.AuditAbstractModel`
    """

    id = models.UUIDField(primary_key=True, default=uuid.uuid4)  # noqa: A003
    is_active = models.BooleanField(default=True, verbose_name=_("active?"))

    FILTER_FIELDS = {
        "id": ["exact", "in"],
        "is_active": ["exact"],
        **AuditAbstractModel.FILTER_FIELDS,
    }

    @admin.display(description=_("internal code"))
    @cached_property
    def icode(self):
        """
        Internal code extracted from model and ID value.

        Example A:

            - app_label is "app"
            - model is "ModelClass"
            - ID is "2a74c335-07aa-45b1-8fac-0b8431be4e09"

        Then code is: "AMC:0B8431BE4E09"

        Example B:

            - app_label is "app"
            - model is "Model"
            - ID is "2a74c335-07aa-45b1-8fac-0b8431be4e09"

        Then code is: "AML:0B8431BE4E09"

        """
        app_label = self._meta.app_label
        _name = self._meta.model.__name__
        initials = [c for c in _name if c.isupper()]
        if len(initials) > 1:
            cls_name = "".join(n[0] for n in initials)
        else:
            cls_name = _name[0] + _name[-1]

        _code = str(self.pk)[-12:]
        return f"{app_label[:2]}{cls_name}:{_code}".upper()

    def __str__(self):
        return self.icode

    class Meta:
        abstract = True
        ordering = ["id"]


class NamedAbstractModel(BleacherMixin, BaseAbstractModel):
    """
    Abstract model for models with unique field ``name``.

    :ivar  text  name:     Unique key. *required*. Instance name.
    :ivar  text  details:  Description
        (accepts `markdown syntax <https://www.markdownguide.org/cheat-sheet/>`__).

    .. note:: Listed values are default ordered by `name` ascending.
    .. note:: Extends from :class:`biskit.core.models.BaseAbstractModel`
    .. note:: Extends from :class:`ai_django_core.mixins.bleacher.BleacherMixin`
    """

    name = models.CharField(max_length=540, unique=True, verbose_name=_("name"))
    details = models.TextField(blank=True, null=True, verbose_name=_("details"))

    BLEACH_FIELD_LIST = ["details"]

    SEARCH_FIELDS = ["name", "details"]
    FILTER_FIELDS = {
        "name": ["exact", "in", "istartswith", "icontains", "iendswith"],
        "details": ["exact", "istartswith", "icontains", "iendswith"],
        **BaseAbstractModel.FILTER_FIELDS,
    }

    def natural_key(self):
        return (self.name,)

    def __str__(self):
        return self.name

    class Meta:
        abstract = True
        ordering = ["name"]
